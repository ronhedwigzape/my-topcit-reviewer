### **1.3 Software analysis and design**

*1.3.1 Software requirements analysis*

- **Definition and classes of software requirements (ISO 29148)**: Software requirements are a detailed description of what a software system should do. ISO 29148 is the international standard for the processes and products of requirements engineering, including the definition and management of requirements.

- **Software requirements elicitation methods**: These are the techniques used to gather requirements from stakeholders and users, like interviews, questionnaires, user observation, workshops, brain storming, role-playing, and prototyping.

- **Analysis of software requirements**: Involves structured analysis and object-oriented analysis to ensure that the requirements are actionable, measurable, testable, related to identified business needs or opportunities, and defined to a level of detail sufficient for system design.

- **Specifications of software requirements**: The process of documenting the requirements and involves the description of the system's services, constraints, and how it will react to specific inputs or conditions【63†source】.

*1.3.1.2 Structured analysis*

- **Structured analysis tools**: Context diagrams, Data Flow Diagrams (DFDs), Data Dictionary (DD), and mini-specifications are used to represent the processes, data stores, and data flows in a system【69†source】.

*1.3.1.3 Object-oriented analysis*

- **Object-oriented analysis tools**: Scenarios, Domain models, Use-case models are developed, often utilizing UML diagrams like Use case diagrams, Class diagrams, Sequence diagrams, Activity diagrams to model the system from an object-oriented perspective.

*1.3.1.4 Verification and documentation of requirements*

- **Requirements verification**: Techniques like inspection, walk-throughs, and technical reviews are used to verify that the requirements are complete, consistent, unambiguous, verifiable, and compliant with standards.

- **Types of requirements specification documents**: Software Requirements Specification (SRS), Software System Requirements (SyRS), User Requirements Specification (URS) documents are prepared to capture all the details.

*1.3.2 Software design principles and structured design*

- **Software design principles**: Include decomposition, abstraction, information hiding, stepwise refinement, modularity, and structuralization which guide the organization and modularization of software systems.

- **Cohesion and coupling as module design criteria**:
  - **Cohesion**: Measures the degree to which the elements inside a module belong together. Higher cohesion is better.
  - **Coupling**: Refers to the degree of interdependence between modules. Lower coupling is better.

*1.3.3 Software architecture design*

- **Basic concepts of software architecture**: Refers to the fundamental organization of a system embodied in its components, their relationships to each other, and to the environment, and the principles guiding its design and evolution.

- **Software architecture components and frameworks**: IEEE-1471 provides guidelines for the description of software architectures, and ATAM, CBAM are methods for evaluating the qualities of software architecture.

*1.3.4 Object-oriented design*

- **Object-oriented design principles**: Emphasize aspects like abstraction, encapsulation, inheritance, and polymorphism and apply design principles such as Single Responsibility Principle (SRP), Open/Closed Principle (OCP), Liskov Substitution Principle (LSP), Interface Segregation Principle (ISP), Dependency Inversion Principle (DIP), and Don't Repeat Yourself (DRY).

- **Static and dynamic modeling**: Utilizes UML to represent static aspects like classes and attributes, and dynamic behaviors like interactions and state changes of the system.

*1.3.5 UI/UX design*

- **Principles of UI/UX design**: Focus on creating designs that are consistent, provide appropriate user support, offer adequate feedback, require minimum user input, and have simple error handling.

- **Design tools for UI/UX**: Tools like Personas, Wireframes, Mockups, Prototypes, and Storyboards are used to visualize and test the design before full-scale development.
